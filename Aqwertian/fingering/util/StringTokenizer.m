//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/nziebart/GoogleDrive/Aqwertian/Aqwertian/fingering/util/StringTokenizer.java
//
//  Created by nziebart on 9/17/12.
//

#import "Aqwertian/fingering/util/StringTokenizer.h"
#import "IOSIntArray.h"
#import "java/lang/Character.h"
#import "java/lang/NullPointerException.h"
#import "java/util/Enumeration.h"
#import "java/util/NoSuchElementException.h"

@implementation AqwertianFingeringUtilStringTokenizer

- (int)currentPosition {
  return currentPosition_;
}

- (void)setCurrentPosition:(int)newCurrentPosition {
  currentPosition_ = newCurrentPosition;
}

- (int)newPosition {
  return newPosition_;
}

- (void)setNewPosition:(int)newNewPosition {
  newPosition_ = newNewPosition;
}

- (int)maxPosition {
  return maxPosition_;
}

- (void)setMaxPosition:(int)newMaxPosition {
  maxPosition_ = newMaxPosition;
}

- (NSString *)str {
  return str_;
}

- (void)setStr:(NSString *)newStr {
  str_ = newStr;
}

- (NSString *)delimiters {
  return delimiters_;
}

- (void)setDelimiters:(NSString *)newDelimiters {
  delimiters_ = newDelimiters;
}

- (BOOL)retDelims {
  return retDelims_;
}

- (void)setRetDelims:(BOOL)newRetDelims {
  retDelims_ = newRetDelims;
}

- (BOOL)delimsChanged {
  return delimsChanged_;
}

- (void)setDelimsChanged:(BOOL)newDelimsChanged {
  delimsChanged_ = newDelimsChanged;
}

- (int)maxDelimCodePoint {
  return maxDelimCodePoint_;
}

- (void)setMaxDelimCodePoint:(int)newMaxDelimCodePoint {
  maxDelimCodePoint_ = newMaxDelimCodePoint;
}

- (BOOL)hasSurrogates {
  return hasSurrogates_;
}

- (void)setHasSurrogates:(BOOL)newHasSurrogates {
  hasSurrogates_ = newHasSurrogates;
}

- (IOSIntArray *)delimiterCodePoints {
  return delimiterCodePoints_;
}

- (void)setDelimiterCodePoints:(IOSIntArray *)newDelimiterCodePoints {
  delimiterCodePoints_ = newDelimiterCodePoints;
}


- (void)setMaxDelimCodePoint {
  if (delimiters_ == nil) {
    maxDelimCodePoint_ = 0;
    return;
  }
  int m = 0;
  int c;
  int count = 0;
  for (int i = 0; i < [NIL_CHK(delimiters_) length]; i += [JavaLangCharacter charCountWithInt:c]) {
    c = [NIL_CHK(delimiters_) charAtWithInt:i];
    if (c >= [JavaLangCharacter MIN_HIGH_SURROGATE] && c <= [JavaLangCharacter MAX_LOW_SURROGATE]) {
      c = [NIL_CHK(delimiters_) codePointAt:i];
      hasSurrogates_ = YES;
    }
    if (m < c) m = c;
    count++;
  }
  maxDelimCodePoint_ = m;
  if (hasSurrogates_) {
    delimiterCodePoints_ = [[IOSIntArray alloc] initWithLength:count];
    for (int i = 0, j = 0; i < count; i++, j += [JavaLangCharacter charCountWithInt:c]) {
      c = [NIL_CHK(delimiters_) codePointAt:j];
      [((IOSIntArray *) NIL_CHK(delimiterCodePoints_)) replaceIntAtIndex:i withInt:c];
    }
  }
}

- (id)initWithNSString:(NSString *)str
          withNSString:(NSString *)delim
              withBOOL:(BOOL)returnDelims {
  if ((self = [super init])) {
    hasSurrogates_ = NO;
    currentPosition_ = 0;
    newPosition_ = -1;
    delimsChanged_ = NO;
    self.str = str;
    maxPosition_ = [NIL_CHK(str) length];
    delimiters_ = delim;
    retDelims_ = returnDelims;
    [self setMaxDelimCodePoint];
  }
  return self;
}

- (id)initWithNSString:(NSString *)str
          withNSString:(NSString *)delim {
  return [self initWithNSString:str withNSString:delim withBOOL:NO];
}

- (id)initWithNSString:(NSString *)str {
  return [self initWithNSString:str withNSString:@" \t\n\r\f" withBOOL:NO];
}

- (int)skipDelimitersWithInt:(int)startPos {
  if (delimiters_ == nil) @throw [[JavaLangNullPointerException alloc] init];
  int position = startPos;
  while (!retDelims_ && position < maxPosition_) {
    if (!hasSurrogates_) {
      unichar c = [NIL_CHK(str_) charAtWithInt:position];
      if ((c > maxDelimCodePoint_) || ([NIL_CHK(delimiters_) indexOf:c] < 0)) break;
      position++;
    }
    else {
      int c = [NIL_CHK(str_) codePointAt:position];
      if ((c > maxDelimCodePoint_) || ![self isDelimiterWithInt:c]) {
        break;
      }
      position += [JavaLangCharacter charCountWithInt:c];
    }
  }
  return position;
}

- (int)scanTokenWithInt:(int)startPos {
  int position = startPos;
  while (position < maxPosition_) {
    if (!hasSurrogates_) {
      unichar c = [NIL_CHK(str_) charAtWithInt:position];
      if ((c <= maxDelimCodePoint_) && ([NIL_CHK(delimiters_) indexOf:c] >= 0)) break;
      position++;
    }
    else {
      int c = [NIL_CHK(str_) codePointAt:position];
      if ((c <= maxDelimCodePoint_) && [self isDelimiterWithInt:c]) break;
      position += [JavaLangCharacter charCountWithInt:c];
    }
  }
  if (retDelims_ && (startPos == position)) {
    if (!hasSurrogates_) {
      unichar c = [NIL_CHK(str_) charAtWithInt:position];
      if ((c <= maxDelimCodePoint_) && ([NIL_CHK(delimiters_) indexOf:c] >= 0)) position++;
    }
    else {
      int c = [NIL_CHK(str_) codePointAt:position];
      if ((c <= maxDelimCodePoint_) && [self isDelimiterWithInt:c]) position += [JavaLangCharacter charCountWithInt:c];
    }
  }
  return position;
}

- (BOOL)isDelimiterWithInt:(int)codePoint {
  for (int i = 0; i < (int) [((IOSIntArray *) NIL_CHK(delimiterCodePoints_)) count]; i++) {
    if ([((IOSIntArray *) NIL_CHK(delimiterCodePoints_)) intAtIndex:i] == codePoint) {
      return YES;
    }
  }
  return NO;
}

- (BOOL)hasMoreTokens {
  newPosition_ = [self skipDelimitersWithInt:currentPosition_];
  return (newPosition_ < maxPosition_);
}

- (NSString *)nextToken {
  currentPosition_ = (newPosition_ >= 0 && !delimsChanged_) ? newPosition_ : [self skipDelimitersWithInt:currentPosition_];
  delimsChanged_ = NO;
  newPosition_ = -1;
  if (currentPosition_ >= maxPosition_) @throw [[JavaUtilNoSuchElementException alloc] init];
  int start = currentPosition_;
  currentPosition_ = [self scanTokenWithInt:currentPosition_];
  return [NIL_CHK(str_) substring:start endIndex:currentPosition_];
}

- (NSString *)nextTokenWithNSString:(NSString *)delim {
  delimiters_ = delim;
  delimsChanged_ = YES;
  [self setMaxDelimCodePoint];
  return [self nextToken];
}

- (BOOL)hasMoreElements {
  return [self hasMoreTokens];
}

- (id)nextElement {
  return [self nextToken];
}

- (int)countTokens {
  int count = 0;
  int currpos = currentPosition_;
  while (currpos < maxPosition_) {
    currpos = [self skipDelimitersWithInt:currpos];
    if (currpos >= maxPosition_) break;
    currpos = [self scanTokenWithInt:currpos];
    count++;
  }
  return count;
}

@end


